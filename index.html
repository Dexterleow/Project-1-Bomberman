<!doctype html>
<meta charset="utf-8">
<title>Special Bomberman</title>

<style>
*
{
  padding: 0px;
  margin: 0px;
}

#stage
{
  position:relative;
  width:832px;
  height:704px;
  background-image: url("/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/background.jpg");
}


.cell
{
  display: block;
  position: absolute;
  width: 64px;
  height: 64px;
}

h1
{
  text-align: center;
  font-family: Arial;
  font-size: 50px;
}

p
{
  font-family: Arial;
  font-size: 20px;
  width: 384px;
  padding: 10px;
}

</style>

<section id="game">
  <h1>Super Bomberman Remake</h1>
  <div id="stage"></div>
  <p id="output"></p>
</section>

<script>

//Get a reference to the stage and output
var stage = document.querySelector("#stage");
var output = document.querySelector("#output");

//Add a keyboard listener
window.addEventListener("keydown", keydownHandler, false);

//The game map
var map = [
  [0,0,0,1,1,0,0,0,1,0,0,0,0],
  [0,2,1,2,0,2,0,2,0,2,0,2,0],
  [0,0,1,0,1,0,1,2,1,0,0,0,0],
  [0,2,0,2,1,2,0,2,1,2,1,2,1],
  [0,0,0,0,1,1,1,1,2,0,0,0,0],
  [0,2,0,2,0,2,2,2,0,2,0,2,1],
  [0,2,0,0,0,0,0,1,1,0,0,0,0],
  [0,2,1,2,0,2,1,2,0,2,0,2,0],
  [1,1,2,0,0,0,1,1,0,1,1,0,0],
  [0,2,0,2,0,2,0,2,1,2,0,2,1],
  [1,0,0,0,1,1,1,0,2,0,1,0,0],
];

//The game objects map
var gameObjects = [
  [5,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,4,0],
  [0,0,0,0,6,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,7,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
];
// change 0 to softWall and hardwall for the object to stop bumping into it.


//Map code
var WATER = 0;
var ISLAND = 1; //softWall
var PIRATE = 2; //hardWall
var HOME = 3;
var MONSTER = 4;
var SHIP = 5;
var MONSTER_TWO = 6;
var MONSTER_THREE = 7;
var MONSTER_FOUR = 8;
var MONSTER_FIVE = 9;
var WATER2 = 10;

//The size of each cell
var SIZE = 64;

//The number of rows and columns
var ROWS = map.length;
var COLUMNS = map[0].length;

//Find the ship's and monster's start positions
var shipRow;
var shipColumn;
var monsterRow;
var monsterColumn;
var monsterRow_Two;
var monsterColumn_Two;
var monsterRow_Three;
var monsterColumn_Three;
var monsterRow_Four;
var monsterColumn_Four;
var monsterRow_Five;
var monsterColumn_Five;

for(var row = 0; row < ROWS; row++)
{
  for(var column = 0; column < COLUMNS; column++)
  {
    if(gameObjects[row][column] === SHIP)
    {
      shipRow = row;
      shipColumn = column;
    }
    if(gameObjects[row][column] === MONSTER)
    {
      monsterRow = row;
      monsterColumn = column;
    }
    if (gameObjects[row][column] === MONSTER_TWO)
    {
      monsterRow_Two = row;
      monsterColumn_Two = column;
    }
    if (gameObjects[row][column] === MONSTER_THREE)
    {
      monsterRow_Three = row;
      monsterColumn_Three = column;
    }
    // if (gameObjects[row][column] === MONSTER_FOUR)
    // {
    //   monsterRow_Four = row;
    //   monsterColumn_Four = column;
    // }
    // if (gameObjects[row][column] === MONSTER_FIVE)
    // {
    //   monsterRow_Five = row;
    //   monsterColumn_Five = column;
    // }
  }
}


//Arrow key codes
var UP = 38; //Keycode for up
var DOWN = 40; //Keycode for down
var RIGHT = 39; //Keycode for right
var LEFT = 37; //Keycode for left
var SPACEBAR = 32; //Keycode for Spacebar

render();

function keydownHandler(event)
{
  switch(event.keyCode)
  {
    case UP:
    if(shipRow > 0)
    {
      //Clear the ship's current cell
      gameObjects[shipRow][shipColumn] = 0;

      //Subract 1 from the ship's row
      shipRow--;

      //Apply the ship's new updated position to the array
      gameObjects[shipRow][shipColumn] = SHIP;
    }
    break;

    case DOWN:
    if(shipRow < ROWS - 1)
    {
      gameObjects[shipRow][shipColumn] = 0;
      shipRow++;
      gameObjects[shipRow][shipColumn] = SHIP;
    }
    break;

    case LEFT:
    if(shipColumn > 0)
    {
      gameObjects[shipRow][shipColumn] = 0;
      shipColumn--;
      gameObjects[shipRow][shipColumn] = SHIP;
    }
    break;

    case RIGHT:
    if(shipColumn < COLUMNS - 1)
    {
      gameObjects[shipRow][shipColumn] = 0;
      shipColumn++;
      gameObjects[shipRow][shipColumn] = SHIP;
    }
    break;

    case SPACEBAR:
    {
      console.log("A Bomb has been planted.");
      placeBomb();
    }
    break;
  }

  //find out what kind of cell the ship is on
  switch(map[shipRow][shipColumn])
  {
    case WATER:
    gameMessage = "You sail the open seas."
    break;

    case PIRATE:
    // fight();
    break;

    case ISLAND:
    // trade();
    break;

    case HOME:
    // endGame();
    break;
  }


  //Move the monster.no1
  moveMonster();
  //Move the monster.no2
  moveMonster_Two();
  //Move the monster.no3
  moveMonster_Three();
  // //Move the monster.no4
  // moveMonster_Four();
  // //Move the monster.no5
  // moveMonster_Five();

  //Find out if the ship is touching the monster
  if(gameObjects[shipRow][shipColumn] === MONSTER)
  {
    endGame();
  }


  //Render the game
  render();
}


//Bomb
var bombPack = 10
// number of bombs
function placeBomb(){
  // if(placebomb && player.bombs != 0)
  //     map[shipColumn][shipRow].object = 2;
  {
    var bombRow = shipRow;
    var bombColumn = shipColumn;
    //placebomb = false;
    bombPack--;
    setTimeout(explode, 3000);
    console.log("Bomb has been triggered");
  }
  function explode(){
    alert('BOOM!');
    //delete map[bombY][bombX].object;
    //turn the soft wall into soft tile.
    //turning an arrary value from something to 0
    //above, below, right, left tiles into standard tiles.
    // if map 3 or 4 turn it into 0
    // turn from 1 into 0
    // var map
    // function isBigEnough(value) {
    //   return value = 1;
    // }
    // var filtered = map.filter(isBigEnough);
    // // filtered is [12, 130, 44]
    // console.log("Array Filtered");

    // var i = map[bombRow][++bombColumn];
    console.log("Row: ", bombRow, "Col: ", bombColumn);
    // var j = map[shipRow - 1][shipColumn - 1];
    // map[i] = '1';
    map[bombRow][++bombColumn] = '0'; //bombed the right tile
    map[bombRow][--bombColumn] = '0'; // bombed the original bomb spot
    map[++bombRow][bombColumn] = '0'; //bombed one tile below
    map[bombRow - 1][bombColumn - 1] ='0';                                  //bombed the left tile
    map[bombRow - 2][bombColumn] ='0'; //bombed the above tile

    bombPack++;
  }
  console.log("Change the softWall into standardTile")
}

// var i = map[shipRow][++shipColumn];
// console.log("Row: ", shipRow, "Col: ", shipColumn);
// // var j = map[shipRow - 1][shipColumn - 1];
// // map[i] = '1';
// map[shipRow][shipColumn] = '1';
// // map[j] = '1';
// bombPack++; //Keep for Reference


function moveMonster() //Movement for monster.no1
{
  //The 4 possible directions that the monster can move
  var UP = 1;
  var DOWN = 2;
  var LEFT = 3;
  var RIGHT = 4;

  //An array to store the valid direction that
  //the monster is allowed to move in
  var validDirections = [];

  //The final direction that the monster will move in
  var direction = undefined;

  //Find out what kinds of things are in the cells
  //that surround the monster. If the cells contain water,
  //push the corresponding direction into the validDirections array
  if(monsterRow > 0)
  {
    var thingAbove = map[monsterRow - 1][monsterColumn];
    if(thingAbove === WATER)
    {
      validDirections.push(UP);
    }
  }
  if(monsterRow < ROWS - 1)
  {
    var thingBelow = map[monsterRow + 1][monsterColumn];
    if(thingBelow === WATER)
    {
      validDirections.push(DOWN);
    }
  }
  if(monsterColumn > 0)
  {
    var thingToTheLeft = map[monsterRow][monsterColumn - 1];
    if(thingToTheLeft === WATER)
    {
      validDirections.push(LEFT);
    }
  }
  if(monsterColumn < COLUMNS - 1)
  {
    var thingToTheRight = map[monsterRow][monsterColumn + 1];
    if(thingToTheRight === WATER)
    {
      validDirections.push(RIGHT);
    }
  }

  //The validDirections array now contains 0 to 4 directions that the
  //contain WATER cells. Which of those directions will the monster
  //choose to move in?

  //If a valid direction was found, Randomly choose one of the
  //possible directions and assign it to the direction variable
  if(validDirections.length !== 0)
  {
    var randomNumber = Math.floor(Math.random() * validDirections.length);
    direction = validDirections[randomNumber];
  }

  //Move the monster in the chosen direction
  switch(direction)
  {
    case UP:
    //Clear the monster's current cell
    gameObjects[monsterRow][monsterColumn] = 0;
    //Subtract 1 from the monster's row
    monsterRow--;
    //Apply the monster's new updated position to the array
    gameObjects[monsterRow][monsterColumn] = MONSTER;
    break;

    case DOWN:
    gameObjects[monsterRow][monsterColumn] = 0;
    monsterRow++;
    gameObjects[monsterRow][monsterColumn] = MONSTER;
    break;

    case LEFT:
    gameObjects[monsterRow][monsterColumn] = 0;
    monsterColumn--;
    gameObjects[monsterRow][monsterColumn] = MONSTER;
    break;

    case RIGHT:
    gameObjects[monsterRow][monsterColumn] = 0;
    monsterColumn++;
    gameObjects[monsterRow][monsterColumn] = MONSTER;
    console.log("monster_one moving out");
  }
}


function moveMonster_Two() //Movement for monster.no2
{
  //The 4 possible directions that the monster can move
  var UP = 1;
  var DOWN = 2;
  var LEFT = 3;
  var RIGHT = 4;

  //An array to store the valid direction that
  //the monster is allowed to move in
  var validDirections = [];

  //The final direction that the monster will move in
  var direction = undefined;

  //Find out what kinds of things are in the cells
  //that surround the monster. If the cells contain water,
  //push the corresponding direction into the validDirections array
  if(monsterRow_Two > 0)
  {
    var thingAbove = map[monsterRow_Two - 1][monsterColumn_Two];
    if(thingAbove === WATER);
    {
      validDirections.push(UP);
    }
  }
  if(monsterRow_Two < ROWS - 1)
  {
    var thingBelow = map[monsterRow_Two + 1][monsterColumn_Two];
    if(thingBelow === WATER)
    {
      validDirections.push(DOWN);
    }
  }
  if(monsterColumn_Two > 0)
  {
    var thingToTheLeft = map[monsterRow_Two][monsterColumn_Two - 1];
    if(thingToTheLeft === WATER)
    {
      validDirections.push(LEFT);
    }
  }
  if(monsterColumn_Two < COLUMNS - 1)
  {
    var thingToTheRight = map[monsterRow_Two][monsterColumn_Two + 1];
    if(thingToTheRight === WATER)
    {
      validDirections.push(RIGHT);
    }
  }

  //The validDirections array now contains 0 to 4 directions that the
  //contain WATER cells. Which of those directions will the monster
  //choose to move in?

  //If a valid direction was found, Randomly choose one of the
  //possible directions and assign it to the direction variable
  if(validDirections.length !== 0)
  {
    var randomNumber = Math.floor(Math.random() * validDirections.length);
    direction = validDirections[randomNumber];
  }

  //Move the monster in the chosen direction
  switch(direction)
  {
    case UP:
    //Clear the monster's current cell
    gameObjects[monsterRow_Two][monsterColumn_Two] = 0;
    //Subtract 1 from the monster's row
    monsterRow_Two--;
    //Apply the monster's new updated position to the array
    gameObjects[monsterRow_Two][monsterColumn_Two] = MONSTER_TWO;
    break;

    case DOWN:
    gameObjects[monsterRow_Two][monsterColumn_Two] = 0;
    monsterRow_Two++;
    gameObjects[monsterRow_Two][monsterColumn_Two] = MONSTER_TWO;
    break;

    case LEFT:
    gameObjects[monsterRow_Two][monsterColumn_Two] = 0;
    monsterColumn_Two--;
    gameObjects[monsterRow_Two][monsterColumn_Two] = MONSTER_TWO;
    break;

    case RIGHT:
    gameObjects[monsterRow_Two][monsterColumn_Two] = 0;
    monsterColumn_Two++;
    gameObjects[monsterRow_Two][monsterColumn_Two] = MONSTER_TWO;
    console.log("monster_two moving out");
  }
}

function moveMonster_Three() //Movement for monster.no3
{
  //The 4 possible directions that the monster can move
  var UP = 1;
  var DOWN = 2;
  var LEFT = 3;
  var RIGHT = 4;

  //An array to store the valid direction that
  //the monster is allowed to move in
  var validDirections = [];

  //The final direction that the monster will move in
  var direction = undefined;

  //Find out what kinds of things are in the cells
  //that surround the monster. If the cells contain water,
  //push the corresponding direction into the validDirections array
  if(monsterRow_Three > 0)
  {
    var thingAbove = map[monsterRow_Three - 1][monsterColumn_Three];
    {
      validDirections.push(UP);
    }
  }
  if(monsterRow_Three < ROWS - 1)
  {
    var thingBelow = map[monsterRow_Three + 1][monsterColumn_Three];
    {
      validDirections.push(DOWN);
    }
  }
  if(monsterColumn_Three > 0)
  {
    var thingToTheLeft = map[monsterRow_Three][monsterColumn_Three - 1];
    if(thingToTheLeft === WATER)
    {
      validDirections.push(LEFT);
    }
  }
  if(monsterColumn_Three < COLUMNS - 1)
  {
    var thingToTheRight = map[monsterRow_Three][monsterColumn_Three + 1];
    if(thingToTheRight === WATER)
    {
      validDirections.push(RIGHT);
    }
  }

  //The validDirections array now contains 0 to 4 directions that the
  //contain WATER cells. Which of those directions will the monster
  //choose to move in?

  //If a valid direction was found, Randomly choose one of the
  //possible directions and assign it to the direction variable
  if(validDirections.length !== 0)
  {
    var randomNumber = Math.floor(Math.random() * validDirections.length);
    direction = validDirections[randomNumber];
  }

  //Move the monster in the chosen direction
  switch(direction)
  {
    case UP:
    //Clear the monster's current cell
    gameObjects[monsterRow_Three][monsterColumn_Three] = 0;
    //Subtract 1 from the monster's row
    monsterRow_Three--;
    //Apply the monster's new updated position to the array
    gameObjects[monsterRow_Three][monsterColumn_Three] = MONSTER_THREE;
    break;

    case DOWN:
    gameObjects[monsterRow_Three][monsterColumn_Three] = 0;
    monsterRow_Three++;
    gameObjects[monsterRow_Three][monsterColumn_Three] = MONSTER_THREE;
    break;

    case LEFT:
    gameObjects[monsterRow_Three][monsterColumn_Three] = 0;
    monsterColumn_Three--;
    gameObjects[monsterRow_Three][monsterColumn_Three] = MONSTER_THREE;
    break;

    case RIGHT:
    gameObjects[monsterRow_Three][monsterColumn_Three] = 0;
    monsterColumn_Three++;
    gameObjects[monsterRow_Three][monsterColumn_Three] = MONSTER_THREE;
    console.log("monster_three moving out");
  }
}



function endGame()
{
  // if(map[shipRow][shipColumn] === HOME)
  // {
  //   //Calculate the score
  //   var score = food + gold + experience;
  //
  //   //Display the game message
  //   gameMessage
  //     = "You made it home ALIVE! " + "Final Score: " + score;
  // }
  // else if(gameObjects[shipRow][shipColumn] === MONSTER)
  // {
  //   gameMessage
  //     = "Your ship has been swallowed by a sea monster!";
  // }
  // else
  // {
  //   //Display the game message
  //   if(gold <= 0)
  //   {
  //     gameMessage += " You've run out of gold!";
  //   }
  //   else
  //   {
  //     gameMessage += " You've run out of food!";
  //   }
  //
  //   gameMessage
  //     += " Your crew throws you overboard!";
  // }

  //Remove the keyboard listener to end the game
  window.removeEventListener("keydown", keydownHandler, false);
}

function render()
{
  //Clear the stage of img cells
  //from the previous turn

  if(stage.hasChildNodes())
  {
    for(var i = 0; i < ROWS * COLUMNS; i++)
    {
      stage.removeChild(stage.firstChild);
    }
  }

  //Render the game by looping through the map arrays
  for(var row = 0; row < ROWS; row++)
  {
    for(var column = 0; column < COLUMNS; column++)
    {
      //Create a img tag called cell
      var cell = document.createElement("img");

      //Set it's CSS class to "cell"
      cell.setAttribute("class", "cell");

      //Add the img tag to the <div id="stage"> tag
      stage.appendChild(cell);

      //Find the correct image for this map cell
      switch(map[row][column])
      {
        case WATER:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/standardTile.png";
        break;

        case ISLAND:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/softWall.png";
        break;

        case PIRATE:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/hardWall.png";
        break;

        // case HOME:
        //   cell.src = "../images/home.png";
        //   break;
      }

      //Add the ship and monster from the gameObjects array
      switch(gameObjects[row][column])
      {

        case WATER2:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/standardTile.png";
        break;

        case SHIP:
        cell.src ="/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/mainHero_front_view.png";
        break;

        case MONSTER:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/botSpider.png";
        break;

        case MONSTER_TWO:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/botSpider.png";
        break;

        case MONSTER_THREE:
        cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/botSpider.png";
        break;

        // case MONSTER_FOUR:
        // cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/botSpider.png";
        // break;
        //
        // case MONSTER_FIVE:
        // cell.src = "/Users/dexterleow/Desktop/Project-1-Bomberman/img/Games-Artwork/botSpider.png";
        // break;
      }

      //Position the cell
      cell.style.top = row * SIZE + "px";
      cell.style.left = column * SIZE + "px";
    }
  }

  //Display the game message
  // output.innerHTML = gameMessage;
  //
  // //Display the player's food, gold, and experience
  // output.innerHTML
  //   += "<br>Gold: " + gold + ", Food: "
  //   + food + ", Experience: " + experience;
}





//collision detection.



</script>
